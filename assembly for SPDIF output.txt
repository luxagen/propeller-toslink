parameters:
[IN] hub long* src ' address of 32-bit frame with bits 0..3 zeroed
'[IN] hub word* bmc_table ' address of LUT of BMC patterns for prior 0 and a byte of data - store this above 496 longs in application image to prevent copying to cog when assembly is started

[IN] cog word bmc_table[256] ' address of LUT of BMC patterns for prior 0 and a byte of data

variables:
frame
temp
signal ' MSb will be starting state for BMC
counter = 1
preamble

' initialise PLLA and video generator here

rdlong frame,src ' get frame to encode

: loop

' ========== FIRST HALF OF FRAME

' generate the correct preamble for this frame - always 5 instructions
add counter,#-1 wz
if_nz jmp :preamble_xy
mov counter,#192
mov preamble_xor,preamble_Z_xor
jmp :preamble_done
:preamble_xy
test counter,#1 wz
if_z mov preamble_xor,preamble_X_xor
if_nz mov preamble_xor,preamble_Y_xor
:preamble_done

' read the bmc_table entry containing the 16-bit pattern for frame[0..7]
mov temp,frame
and temp,#$FF
ror temp,1 wc ' generate the number of the register we want from the BMC table
add temp,@bmc_table ' temp now contains the register number of the entry we want
movs #$+2,temp ' modify the read instruction
test signal,mask_bit31 wz ' find out whether to invert the lookup result (also buffer next instruction after modification)
mov signal,0-0 ' will be modified to read correct entry
xor signal,preamble_xor ' remove BMC pattern from preamble zone and replace with actual preamble
if_z xor signal,all_ones ' invert pattern according to previous finish state
' select the correct subentry and zero the rest
if_nc and signal,low_word_mask
if_c shr signal,#16

' signal's lower half now contains the 16-bit BMC pattern for the first byte of the frame

' read the bmc_table entry containing the 16-bit pattern for frame[8..15]
mov temp,frame
shr temp,#8
and temp,#$FF
ror temp,1 wc ' generate the number of the register we want from the BMC table
add temp,@bmc_table ' temp now contains the register number of the entry we want
movs #$+2,temp ' modify the read instruction
test signal,mask_bit15 wz ' find out whether to invert the lookup result (also buffer next instruction after modification)
mov temp,0-0 ' will be modified to read correct entry
if_z xor temp,all_ones ' invert pattern according to previous finish state
' select the correct subentry and zero the rest
if_nc shl temp,#16
if_c andn temp,low_word_mask

' temp's upper half now contains the 16-bit BMC pattern for the second byte of the frame - combine them
or signal,temp

waitvid palette,signal

' WORST CASE IS 30x4 = 120 CYCLES FOR THIS HALF

' ========== SECOND HALF OF FRAME

' read the bmc_table entry containing the 16-bit pattern for frame[0..7]
mov temp,frame
shr temp,#16
and temp,#$FF
ror temp,1 wc ' generate the number of the register we want from the BMC table
add temp,@bmc_table ' temp now contains the register number of the entry we want
movs #$+2,temp ' modify the read instruction
test signal,mask_bit31 wz ' find out whether to invert the lookup result (also buffer next instruction after modification)
mov signal,0-0 ' will be modified to read correct entry
if_z xor signal,all_ones ' invert pattern according to previous finish state
' select the correct subentry and zero the rest
if_nc and signal,low_word_mask
if_c shr signal,#16

' signal's lower half now contains the 16-bit BMC pattern for the first byte of the frame

' read the bmc_table entry containing the 16-bit pattern for frame[8..15]
mov temp,frame
shr temp,#24
ror temp,1 wc ' generate the number of the register we want from the BMC table
add temp,@bmc_table ' temp now contains the register number of the entry we want
movs #$+2,temp ' modify the read instruction
test signal,mask_bit15 wz ' find out whether to invert the lookup result (also buffer next instruction after modification)
mov temp,0-0 ' will be modified to read correct entry
if_z xor temp,all_ones ' invert pattern according to previous finish state
' select the correct subentry and zero the rest
if_nc shl temp,#16
if_c andn temp,low_word_mask

' temp's upper half now contains the 16-bit BMC pattern for the second byte of the frame - combine them
or signal,temp

rdlong frame,src ' read the next frame here because we have spare cycles

waitvid palette,signal

jmp :loop

' WORST CASE IS 30x4 = 120 CYCLES FOR THIS HALF

' 240 cycles to output one frame, so 480 to output one stereo sample
' so to output a 32 kHz sample-rate requires a 15.36 MHz master clock
' this means that we might get away with an 8x multiplier is clocking to the D-70 sample clock

' for general output, 192 kHz output would require a 92.16 MHz master clock

' the input cog has 16 cycles per bit coming in, so perhaps could be written in Spin?